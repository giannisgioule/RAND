*===============================================================================
*                       optimal_piecewise_regression.gms
*
* This script contains all of the optimisation methods:
* OPLRA: Optimal Piecewise Linear Regression Analysis (Yang et. al. 2016)
* PRIA:  Piecewise Regression with Iterative AIC
* PROA:  Piecewise Regression with Optimised AIC
* PRIB:  Piecewise Regression with Iterative BIC
* PROB:  Piecewise Regression with Optimised BIC
*
* This file is called using an R script. All of the data are preprocessed in R
* and are imported using .xls and .csv files. Depending on which method the user
* chooses in R, this file will only solve the appropriate math. prog. model.
*===============================================================================

*============================ Use multiple threads==============================
$onecho>cplex.opt
threads 12
$offecho
*===============================================================================

*===============================================================================
*---------------------------------BEGIN SCRIPT----------------------------------
*===============================================================================


*--------------------------------DEFINE THE SETS--------------------------------
* Define the sets for the optimisation model. A set is needed for the number of
* partitioning regions (maximum of 8), a set for all the samples in the
* regression dataset, a set to define the input variables and a dynamic set to
* define the partitioning variable that was identified by the file
* identify_partitioning_variable.gms
*-------------------------------------------------------------------------------
sets
r     set of partitioning regions /r1*r8/
s     the set of all the samples
m     the set of all the input variables
part_variable(m) partitioning variable
* This set is only for the single-level MILP models
linear_points    number of points for linear approximation of log(x) /1*5/
* This set is for the iterative models
number_of_iter   number of iterations for the solve loops /2*50/;


*-----------------------DEFINE THE REGRESSION PARAMETERS------------------------
* Define the regression parameters. These include the numerical input values and
* the output for all the values.
* Also define necessary parameters that correspond to the selected regression
* method by the user, the maximum number of selected regions (necessary only
* for the PROA and PROB methods).
*-------------------------------------------------------------------------------
parameters
Y(s)                     Response of dataset
A(s,m)                   Values of dataset
selected_regions         Maximum number of selected regions (single-level MILP only)
max_error
selected_method          Selected regression method
;

*--------------------------------DEFINE SCALARS---------------------------------
* Define two scalars and assign large values to formulate the bigM constraints
* Define the beta parameter that is required for the OPLRA method
* Define a counter to change the number of regions in the loops at the end
* Define a scalar for the maximum number of parameters of the regression models.
* This is necessary for the AIC/BIC metrics, regarding model complexity.
*-------------------------------------------------------------------------------
scalars
U1                       large number for the bigM constraints /10/
U2                       large number for the bigM constraints
OPLRA_beta_parameter     the parameter of the OPLRA stopping criterion /0.03/
total_number_parameters  Total number of parameters in the model
counter                  Change the region /2/
;

*-------------------------LOAD THE DATA GENERATED BY R--------------------------
* After defining the necessary sets and parameters, import their values using
* .gdx files that are generated by R
*-------------------------------------------------------------------------------
$GDXIN "input.gdx"
$LOAD s,m,Y,A,max_error,part_variable,selected_regions,selected_method

* Setting a value for U2, to formulate the bigM constraints
U2=2.5*smax(s,Y(s));
* m parameters for the regression coefficients and +1 for the intercept
total_number_parameters=(card(m)+1);


*---------------------DEFINE LINEAR APPROXIMATION OF LOG(X)---------------------
* To keep all the models as MILP, formulate a linear approximation of the log(x)
* function.
*-------------------------------------------------------------------------------
sos2 variable
lamda(linear_points);

parameter
gamma(linear_points) known break points;

gamma('1')=1;
gamma('5')=1.2*max_error;
loop(linear_points$(ord(linear_points)<card(linear_points)-1),
         gamma(linear_points+1)=gamma(linear_points)+
                 (max_error/card(linear_points));
);

parameters
beta(linear_points)    whatever
;

beta(linear_points) = log(gamma(linear_points)) ;

*----------------------------DEFINE MODEL VARIABLES-----------------------------
* Define all the variables of the optimisation model
* Positive variables:  - Break point(s) (by default the data range is [0,1])
*                      - Absolute deviation between predictions and observations
*
* Free variables:      - Regression coefficients and intercept
*                      - Model predictions
*                      - The objective of the minimisation
*                      - The AIC objective function value
*                      - The BIC objective function value
*
* Binary variables:    - Samples to regions assignment
*                      - Selection of number of regions
*-------------------------------------------------------------------------------

positive variable
X(r,part_variable)   break point r on partion feature m1
D(s)      training error between predicted output and real output for sample s

variables
W(m,r)    regression coefficient for feature m in region r
B(r)      intercept of regression function in region r
Pr(s,r)   predicted output for sample s in region r
error     objective variable for OPLRA and AIC_iter
G         linear approximation of the log function for MILP model
AIC       objective function for MILP
BIC       objective function for MILP;

binary variables

F(s,r) 1 if sample s falls into region r
E(r)   1 if region r is selected only for MILP model;

*----------------------------DEFINE MODEL EQUATIONS-----------------------------
* The following set is true only for the iterative PRIA and PRIB approaches
*-------------------------------------------------------------------------------
equations
eq1_iter(r,part_variable)     Break point arrangement
eq2_iter(s,r,part_variable)   Sample allocation into regions
eq3_iter(s,r,part_variable)   Sample allocation into regions
eq4_iter(s)                   Each sample belongs to one region
eq4_2
eq4_3
eq5_iter(s,r)                 Predicted output for sample s
eq6_iter(s,r)                 Absolute deviation
eq7_iter(s,r)                 Absolute deviation
obj_iter                      Minimazition of absolute training error;

eq1_iter(r,part_variable)$((ord(r) > 1)and(ord(r)<counter))..
         X(r-1,part_variable)=l=X(r,part_variable);


eq2_iter(s,r,part_variable)$((ord(r) > 1)and(ord(r) le counter))..
         X(r-1,part_variable)-U1*(1-F(s,r))+0.001=l=A(s,part_variable);


eq3_iter(s,r,part_variable)$(ord(r) < counter)..
         A(s,part_variable)=l=X(r,part_variable)+U1*(1-F(s,r))-0.001;


eq4_iter(s)..
         sum(r$(ord(r) le counter),F(s,r))=e=1;


eq5_iter(s,r)$(ord(r) le counter)..
         Pr(s,r)=e=sum(m,A(s,m)*W(m,r))+B(r);


eq6_iter(s,r)$(ord(r) le counter)..
         D(s)=g=Y(s)-Pr(s,r)-U2*(1-F(s,r));


eq7_iter(s,r)$(ord(r) le counter)..
         D(s)=g=Pr(s,r)-Y(s)-U2*(1-F(s,r));


obj_iter..
         error=e=sum(s,D(s));

*----------------------------DEFINE MODEL EQUATIONS-----------------------------
* The following set is true only for the PROA and PROB approaches
*-------------------------------------------------------------------------------
equations
eq1_single(r,part_variable)   Break point arrangement
eq2_single(s,r,part_variable) Sample allocation into regions
eq3_single(s,r,part_variable) Sample allocation into regions
eq4_single(s)                 Each sample belongs to one region
eq5_single                  If a regions is selected then a sample can be assigned to it
eq6_single                  If a regions is not selected then none of the following will
eq7_single(s,r)               Predicted output for sample s
eq8_single(s,r)               Absolute deviation
eq9_single(s,r)               Absolute deviation
lin1_single
lin2_single
lin3_single
obj_single_AIC                Minimazition of absolute training error
obj_single_BIC                Minimazition of absolute training error;


eq1_single(r,part_variable)$((ord(r) > 1)and(ord(r)<selected_regions))..
         X(r-1,part_variable)=l=X(r,part_variable);


eq2_single(s,r,part_variable)$((ord(r) > 1)and(ord(r) le selected_regions))..
         X(r-1,part_variable)-U1*(1-F(s,r))+0.001=l=A(s,part_variable);

eq3_single(s,r,part_variable)$(ord(r) < selected_regions)..
         A(s,part_variable)=l=X(r,part_variable)+U1*(1-F(s,r))-0.001;

eq4_single(s)..
         sum(r$(ord(r) le selected_regions),F(s,r))=e=1;

eq5_single(s,r)$(ord(r) le selected_regions)..
         F(s,r)=l=E(r);

eq6_single(r)$(ord(r)< selected_regions)..
         E(r+1)=l=E(r);

eq7_single(s,r)$(ord(r) le selected_regions)..
         Pr(s,r)=e=sum(m,A(s,m)*W(m,r))+B(r);

eq8_single(s,r)$(ord(r) le selected_regions)..
         D(s)=g=Y(s)-Pr(s,r)-U2*(1-F(s,r));

eq9_single(s,r)$(ord(r) le selected_regions)..
         D(s)=g=Pr(s,r)-Y(s)-U2*(1-F(s,r));

lin1_single..
        sum(s,D(s))=e=sum(linear_points,gamma(linear_points)*lamda(linear_points));

lin2_single..
         sum(linear_points,lamda(linear_points))=e=1;

lin3_single..
         G =e= sum(linear_points, beta(linear_points)*lamda(linear_points)) ;

obj_single_AIC..
         AIC=e=card(s)*G -card(s)*log(card(s))+2*total_number_parameters*
                 sum(r$(ord(r) le selected_regions),E(r));
obj_single_BIC..
         BIC=e=card(s)*G -card(s)*log(card(s))+log(card(s))*total_number_parameters*
                 sum(r$(ord(r) le selected_regions),E(r));


*-------------------------------MODEL DEFINITION--------------------------------
* Define 3 MILP models:
* iterative:             MILP that is common for OPLRA, PRIA and PROB
* PROA_approach:         MILP only for PROA
* PROB_approach:         MILP only for PROB
*-------------------------------------------------------------------------------
model iterative     /eq1_iter,eq2_iter,eq3_iter,eq4_iter,eq5_iter,
                                 eq6_iter,eq7_iter,obj_iter/;
model PROA_approach /eq1_single,eq2_single,eq3_single,eq4_single,eq5_single,
                         eq6_single,eq7_single,eq8_single,eq9_single,
                         lin1_single,lin2_single,lin3_single,obj_single_AIC/;
model PROB_approach /eq1_single,eq2_single,eq3_single,eq4_single,eq5_single,
                         eq6_single,eq7_single,eq8_single,eq9_single,
                         lin1_single,lin2_single,lin3_single,obj_single_BIC/;

*--------------------------------SOLVER OPTIONS---------------------------------
* Select the CPLEX solver, set 0% optimality gap and set a CPU limit of 200s for
* the itarative MILP model and 400s for the other two MILP models
*-------------------------------------------------------------------------------
option mip=cplex;
option optcr=0.0;
iterative.resLim=200;
PROA_approach.resLim=400;
PROB_approach.resLim=400;


* PARAMETER
parameters

rss(number_of_iter)      Residual sum of squares
AIC_iter(number_of_iter) Akaike Information Criterion for iterative approaches
BIC_iter(number_of_iter) Bayesian Information Criterion for iterative approaches
result                   Error results of all the iterations
flag                     Logical parameter to stop the loop
true_number_regions      True number of regions
break_point              The breaking point
break_point_iter         The breaking point of each iteration
coefficients             The regression coefficients
intercept                The regression intercept
coefficients_iter        The regression coefficients of each iteration
intercept_iter           The regression intercept of each iteration
mae                      Mean Absolute error
optimality_gap           The optimality gap of the solution
optimality_gap_iter      The optimality gap of the solution of each iteration
;

flag=yes;

*===============================================================================
*                  This loop solves the OPLRA model, if chosen
*===============================================================================
if (selected_method eq 1,
         loop(number_of_iter$((ord(number_of_iter)<card(r))and(flag)),
                 solve iterative using MIP minimizing error;
                 result(number_of_iter)=error.l;
                 break_point_iter(number_of_iter,r,part_variable)=
                         X.l(r,part_variable);
                 intercept_iter(number_of_iter,r)=B.l(r);
                 coefficients_iter(number_of_iter,m,r)=W.l(m,r);
                 optimality_gap_iter(number_of_iter)=
                         abs(iterative.objest-iterative.objval)/
                          max(abs(iterative.objest),abs(iterative.objval));
                 if (ord(number_of_iter) ge 2,
                         if ((result(number_of_iter-1)-result(number_of_iter))/
                              result(number_of_iter-1)<OPLRA_beta_parameter,
                                 true_number_regions=ord(number_of_iter);
                                 flag=no;
                                 break_point(r,part_variable)=
                                   break_point_iter(number_of_iter-1,r,part_variable);
                                 intercept(r)=intercept_iter(number_of_iter-1,r);
                                 coefficients(m,r)=coefficients_iter(number_of_iter-1,m,r);
                                 optimality_gap=optimality_gap_iter(number_of_iter-1);
                         );
                 );
                 counter=counter+1
         );
);
*===============================================================================

*===============================================================================
*                   This loop solves the PRIA model, if chosen
*===============================================================================
if (selected_method eq 2,
         loop(number_of_iter$((ord(number_of_iter)<card(r))and(flag)),
                 solve iterative using MIP minimizing error;
                 rss(number_of_iter)=sum(s,power(D.l(s),2));
                 AIC_iter(number_of_iter)=card(s)*log(rss(number_of_iter)/
                         card(s))+2*(card(m)+1)*counter;
                 break_point_iter(number_of_iter,r,part_variable)=X.l(r,part_variable);
                 intercept_iter(number_of_iter,r)=B.l(r);
                 coefficients_iter(number_of_iter,m,r)=W.l(m,r);
                 optimality_gap_iter(number_of_iter)=abs(iterative.objest-iterative.objval)/
                        max(abs(iterative.objest),abs(iterative.objval));
                 if (ord(number_of_iter) ge 2,
                         if (AIC_iter(number_of_iter)>AIC_iter(number_of_iter-1),
                                 true_number_regions=ord(number_of_iter);
                                 flag=no;
                                 break_point(r,part_variable)=
                                         break_point_iter(number_of_iter-1,r,part_variable);
                                 intercept(r)=intercept_iter(number_of_iter-1,r);
                                 coefficients(m,r)=coefficients_iter(number_of_iter-1,m,r);
                                 optimality_gap=optimality_gap_iter(number_of_iter-1);
                         );
                 );
                 counter=counter+1
         );
);
*===============================================================================

*===============================================================================
*                   This loop solves the PRIB model, if chosen
*===============================================================================
if (selected_method eq 4,
         loop(number_of_iter$((ord(number_of_iter)<card(r))and(flag)),
                 solve iterative using MIP minimizing error;
                 rss(number_of_iter)=sum(s,power(D.l(s),2));
                 BIC_iter(number_of_iter)=card(s)*log(rss(number_of_iter)/card(s))+
                         log(card(s))*(card(m)+1)*counter;
                 break_point_iter(number_of_iter,r,part_variable)=X.l(r,part_variable);
                 intercept_iter(number_of_iter,r)=B.l(r);
                 coefficients_iter(number_of_iter,m,r)=W.l(m,r);
                 optimality_gap_iter(number_of_iter)=abs(iterative.objest-iterative.objval)/
                          max(abs(iterative.objest),abs(iterative.objval));
                 if (ord(number_of_iter) ge 2,
                         if (BIC_iter(number_of_iter)>BIC_iter(number_of_iter-1),
                                 true_number_regions=ord(number_of_iter);
                                 flag=no;
                                 break_point(r,part_variable)=
                                         break_point_iter(number_of_iter-1,r,part_variable);
                                 intercept(r)=intercept_iter(number_of_iter-1,r);
                                 coefficients(m,r)=coefficients_iter(number_of_iter-1,m,r);
                                 optimality_gap=optimality_gap_iter(number_of_iter-1);
                         );
                 );
                 counter=counter+1
         );
);
*===============================================================================

if((selected_method eq 1) or (selected_method eq 2)or (selected_method eq 4),
         if(flag,
                 true_number_regions=card(r);
                 loop((r,part_variable),
                         break_point(r,part_variable)=X.l(r,part_variable);
                         intercept(r)=B.l(r);
                         coefficients(m,r)=W.l(m,r);
                 );
         );


         display 'The number of regions is',true_number_regions;
*         display result,point,inter,coef,AIC_r;

         loop(r,
                 if((intercept(r) eq 0),
                         intercept(r)=EPS
                 );
                 loop(m,
                         if((coefficients(m,r) eq 0),
                                 coefficients(m,r)=EPS
                         );
                 );
         );

         display break_point,intercept,coefficients,optimality_gap;
         execute_unload 'regression_results.gdx',break_point,intercept,
                 coefficients,true_number_regions,optimality_gap;
);


*===============================================================================
*               This loop solves the PROA or PROB model, if chosen
*===============================================================================

if (((selected_method eq 3)or(selected_method eq 5)),
         if(selected_method eq 3,
                 solve PROA_approach using MIP minimizing AIC;
                 optimality_gap=abs(PROA_approach.objest-PROA_approach.objval)/
                         max(abs(PROA_approach.objest),abs(PROA_approach.objval));
                 display optimality_gap;
         );
         if(selected_method eq 5,
                 solve  PROB_approach using MIP minimizing BIC;
                 optimality_gap=abs(PROB_approach.objest-PROB_approach.objval)/
                          max(abs(PROB_approach.objest),abs(PROB_approach.objval));
                 display optimality_gap;
         );
         mae=sum(s,D.l(s));

         break_point(r,part_variable)=X.l(r,part_variable)*E.l(r);
         intercept(r)=B.l(r)*E.l(r);
         coefficients(m,r)=W.l(m,r)*E.l(r);
         loop(r,
                 if((intercept(r) eq 0),
                         intercept(r)=EPS
                 );
                 loop(m,
                         if((coefficients(m,r) eq 0),
                                 coefficients(m,r)=EPS
                         );
                 );
         );

         display break_point,intercept,coefficients,optimality_gap;
         execute_unload 'regression_results.gdx',break_point,intercept,
                 coefficients,optimality_gap;
);

*===============================================================================
*----------------------------------END SCRIPT-----------------------------------
*===============================================================================
